use anyhow::anyhow;
use thiserror::Error;

#[derive(Debug, Error)]
/// Different types of errors that can be generated by a client implementation.
pub enum ClientError {
    /// Rate-limited by remote end because too many requests were sent too quickly.
    #[error("too many requests")]
    RateLimit,
    /// Remote end failed to respond in enough time.
    #[error("request timeout")]
    Timeout,
    /// Other transport-layer errors.
    #[error("transport error")]
    Transport {
        #[source]
        source: anyhow::Error,
    },
    #[error("parse error")]
    /// Errors that occur during parsing.
    Parsing {
        #[source]
        source: anyhow::Error,
    },
}

impl ClientError {
    pub fn transport<E: std::error::Error + Send + Sync + 'static>(error: E) -> Self {
        Self::Transport {
            source: anyhow!(error),
        }
    }

    pub fn parsing<E: std::error::Error + Send + Sync + 'static>(error: E) -> Self {
        Self::Parsing {
            source: anyhow!(error),
        }
    }
}

/// Errors that can occur when parsing Solana API types from a JSON object.
#[derive(Debug, Error)]
pub enum JsonValueParseError {
    NotObject,
    InvalidValue {
        field: &'static str,
        expected: &'static str,
        got: String,
    },
    Subfield {
        field: &'static str,
        error: Box<JsonValueParseError>,
    },
    Bincode {
        #[from]
        source: bincode::Error,
    },
    SerdeJson {
        #[from]
        source: serde_json::Error,
    },
    Base64 {
        #[from]
        source: base64::DecodeError,
    },
    Base58 {
        #[from]
        source: bs58::decode::Error,
    },
}

impl std::fmt::Display for JsonValueParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "JSON value parse error: ")?;
        match self {
            JsonValueParseError::InvalidValue {
                field,
                expected,
                got,
            } => {
                write!(
                    f,
                    "invalid value in field (expected: {}, got: {}): \"{}\"",
                    field, expected, got
                )?;
            }
            JsonValueParseError::SerdeJson { .. } => {
                write!(f, "Serde error")?;
            }
            JsonValueParseError::Base64 { .. } => write!(f, "base64 error")?,
            JsonValueParseError::Bincode { .. } => write!(f, "bincode error")?,
            JsonValueParseError::Subfield { field, error } => {
                write!(f, "subfield error (field {}, {})", field, error)?
            }
            JsonValueParseError::NotObject => write!(f, "is not an object")?,
            JsonValueParseError::Base58 { .. } => write!(f, "base58 error")?,
        }

        Ok(())
    }
}

fn identify_value(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Null => "null".to_string(),
        serde_json::Value::Bool(s) => format!("bool {}", s),
        serde_json::Value::Number(s) => format!("number {}", s),
        serde_json::Value::String(s) => format!("string '{}'", s),
        serde_json::Value::Array(_) => "array".to_string(),
        serde_json::Value::Object(_) => "object".to_string(),
    }
}

impl JsonValueParseError {
    pub fn subfield(field: &'static str, error: Self) -> Self {
        Self::Subfield {
            field,
            error: Box::new(error),
        }
    }

    pub fn invalid_value(
        field: &'static str,
        expected: &'static str,
        got: &serde_json::Value,
    ) -> Self {
        Self::InvalidValue {
            field,
            expected,
            got: identify_value(got),
        }
    }
}
